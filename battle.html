<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brave Frontier Style Battle - Animated Demo</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Orbitron:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #gameCanvas {
            border: 3px solid #6633cc;
            box-shadow: 0 0 50px rgba(100, 50, 200, 0.5),
                0 0 100px rgba(50, 100, 255, 0.3);
            border-radius: 8px;
        }

        #ui-overlay {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .battle-btn {
            padding: 15px 30px;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            border: 2px solid;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .battle-btn.attack {
            background: linear-gradient(180deg, #4a3a8a 0%, #2a1a5a 100%);
            border-color: #8866cc;
        }

        .battle-btn.skill {
            background: linear-gradient(180deg, #3a5a8a 0%, #1a3a5a 100%);
            border-color: #66aacc;
        }

        .battle-btn.burst {
            background: linear-gradient(180deg, #8a5a3a 0%, #5a3a1a 100%);
            border-color: #ccaa66;
        }

        .battle-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(100, 50, 200, 0.5);
        }

        .battle-btn:active {
            transform: translateY(0);
        }

        #combo-display {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: 'Orbitron', sans-serif;
            color: #ffcc00;
            text-shadow: 0 0 20px #ff6600;
            z-index: 100;
            text-align: right;
        }

        #combo-display .number {
            font-size: 48px;
            font-weight: 700;
        }

        #combo-display .label {
            font-size: 14px;
            color: rgba(255, 200, 100, 0.8);
            letter-spacing: 3px;
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: rgba(200, 180, 255, 0.7);
            z-index: 100;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="combo-display">
        <div class="number" id="comboNum">0</div>
        <div class="label">COMBO</div>
    </div>

    <div id="instructions">
        Click buttons or press:<br>
        [A] Attack | [S] Skill | [D] Brave Burst
    </div>

    <div id="ui-overlay">
        <button class="battle-btn attack" onclick="game.attack()">‚öîÔ∏è Attack</button>
        <button class="battle-btn skill" onclick="game.skill()">‚ú® Skill</button>
        <button class="battle-btn burst" onclick="game.braveBurst()">üí• Brave Burst</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = 480;
        canvas.height = 720;

        // Game state
        const game = {
            combo: 0,
            isAnimating: false,
            enemyHP: 50000,
            enemyMaxHP: 50000,
            bbGauge: 0,
            maxBB: 100,

            particles: [],
            damageNumbers: [],
            screenShake: { x: 0, y: 0, intensity: 0 },
            flashAlpha: 0,

            attack() {
                if (this.isAnimating) return;
                this.performAttack('normal', 1500, 1);
            },

            skill() {
                if (this.isAnimating) return;
                this.performAttack('skill', 3500, 3);
            },

            braveBurst() {
                if (this.isAnimating || this.bbGauge < this.maxBB) return;
                this.bbGauge = 0;
                this.performAttack('burst', 10000, 7);
            },

            async performAttack(type, baseDamage, hits) {
                this.isAnimating = true;

                // Hero attack animation
                hero.attacking = true;
                hero.attackType = type;
                hero.attackFrame = 0;

                await sleep(type === 'burst' ? 600 : 300);

                // Multi-hit
                for (let i = 0; i < hits; i++) {
                    const damage = Math.floor(baseDamage / hits + Math.random() * 500);
                    const crit = Math.random() > 0.7;
                    const finalDmg = crit ? Math.floor(damage * 1.5) : damage;

                    // Effects
                    this.screenShake.intensity = type === 'burst' ? 15 : type === 'skill' ? 10 : 5;
                    this.flashAlpha = type === 'burst' ? 0.8 : 0.4;

                    // Enemy hit
                    enemy.hit = true;
                    enemy.hitTimer = 10;

                    // Damage number
                    this.damageNumbers.push({
                        value: finalDmg,
                        x: 240 + (Math.random() - 0.5) * 100,
                        y: 180,
                        vy: -3,
                        alpha: 1,
                        scale: crit ? 1.5 : 1,
                        crit: crit
                    });

                    // Particles
                    this.createImpactParticles(240, 200, type);

                    // Deal damage
                    this.enemyHP = Math.max(0, this.enemyHP - finalDmg);

                    // Combo
                    this.combo++;
                    document.getElementById('comboNum').textContent = this.combo;

                    // BB gauge
                    if (type !== 'burst') {
                        this.bbGauge = Math.min(this.maxBB, this.bbGauge + 8);
                    }

                    await sleep(120);
                    enemy.hit = false;
                }

                hero.attacking = false;

                // Check victory
                if (this.enemyHP <= 0) {
                    await sleep(500);
                    alert('VICTORY! üéâ');
                    this.resetBattle();
                    this.isAnimating = false;
                    return;
                }

                // Enemy counter
                await sleep(400);
                await this.enemyAttack();

                this.isAnimating = false;
            },

            async enemyAttack() {
                enemy.attacking = true;
                await sleep(300);

                this.screenShake.intensity = 8;
                this.flashAlpha = 0.3;
                hero.hit = true;
                hero.hitTimer = 15;

                this.combo = 0;
                document.getElementById('comboNum').textContent = '0';

                await sleep(200);
                enemy.attacking = false;
                hero.hit = false;
            },

            createImpactParticles(x, y, type) {
                const colors = type === 'burst' ? ['#ffcc00', '#ff6600', '#ff0000'] :
                    type === 'skill' ? ['#00ffff', '#0088ff', '#ffffff'] :
                        ['#ffffff', '#aaccff', '#88aaff'];

                const count = type === 'burst' ? 25 : type === 'skill' ? 15 : 8;

                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                    const speed = 3 + Math.random() * 5;

                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: type === 'burst' ? 6 + Math.random() * 6 : 3 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        alpha: 1,
                        life: 30 + Math.random() * 20
                    });
                }
            },

            resetBattle() {
                this.enemyHP = this.enemyMaxHP;
                this.combo = 0;
                this.bbGauge = 0;
            }
        };

        // Hero sprite with animation
        const hero = {
            x: 240,
            y: 550,
            baseY: 550,
            width: 120,
            height: 120,

            // Animation
            frameIndex: 0,
            frameTimer: 0,
            framesPerRow: 4,
            totalFrames: 16,
            frameWidth: 160,
            frameHeight: 160,

            // States
            attacking: false,
            attackType: 'normal',
            attackFrame: 0,
            hit: false,
            hitTimer: 0,

            // Idle bob
            idleOffset: 0,
            idleDir: 1,

            spritesheet: null,

            update() {
                // Frame animation (cycle through spritesheet)
                this.frameTimer++;
                if (this.frameTimer >= 8) {
                    this.frameTimer = 0;
                    this.frameIndex = (this.frameIndex + 1) % this.totalFrames;
                }

                // Idle floating
                this.idleOffset += 0.08 * this.idleDir;
                if (Math.abs(this.idleOffset) > 5) this.idleDir *= -1;

                // Attack animation
                if (this.attacking) {
                    this.attackFrame++;
                    const maxFrames = this.attackType === 'burst' ? 60 : 30;

                    if (this.attackFrame < maxFrames * 0.3) {
                        // Wind up
                        this.y = this.baseY - this.attackFrame * 2;
                    } else if (this.attackFrame < maxFrames * 0.6) {
                        // Lunge to enemy
                        this.y = this.baseY - 150 - (this.attackFrame - maxFrames * 0.3) * 8;
                    } else {
                        // Return
                        this.y += (this.baseY - this.y) * 0.15;
                    }
                } else {
                    this.y = this.baseY + this.idleOffset;
                    this.attackFrame = 0;
                }

                // Hit flash
                if (this.hitTimer > 0) this.hitTimer--;
            },

            draw(ctx) {
                ctx.save();

                // Hit flash
                if (this.hitTimer > 0 && this.hitTimer % 4 < 2) {
                    ctx.globalAlpha = 0.5;
                }

                // Aura glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, 80
                );
                gradient.addColorStop(0, 'rgba(0, 150, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 80, 0, Math.PI * 2);
                ctx.fill();

                // Draw from spritesheet
                if (this.spritesheet && this.spritesheet.complete) {
                    const col = this.frameIndex % this.framesPerRow;
                    const row = Math.floor(this.frameIndex / this.framesPerRow);

                    ctx.drawImage(
                        this.spritesheet,
                        col * this.frameWidth, row * this.frameHeight,
                        this.frameWidth, this.frameHeight,
                        this.x - this.width / 2, this.y - this.height / 2,
                        this.width, this.height
                    );
                } else {
                    // Fallback if spritesheet not loaded
                    ctx.fillStyle = '#4488ff';
                    ctx.fillRect(this.x - 30, this.y - 40, 60, 80);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('HERO', this.x, this.y);
                }

                ctx.restore();
            }
        };

        // Enemy with animation
        const enemy = {
            x: 240,
            y: 200,
            baseY: 200,
            width: 180,
            height: 180,

            // Animation
            scaleX: 1,
            scaleY: 1,
            pulseTimer: 0,

            // States
            hit: false,
            hitTimer: 0,
            attacking: false,

            image: null,

            update() {
                // Breathing/pulse animation
                this.pulseTimer += 0.05;
                this.scaleX = 1 + Math.sin(this.pulseTimer) * 0.03;
                this.scaleY = 1 + Math.cos(this.pulseTimer * 0.8) * 0.05;

                // Float animation
                this.y = this.baseY + Math.sin(this.pulseTimer * 0.7) * 8;

                // Hit shake
                if (this.hit) {
                    this.x = 240 + (Math.random() - 0.5) * 20;
                } else {
                    this.x = 240;
                }

                // Attack lunge
                if (this.attacking) {
                    this.y = this.baseY + 100;
                    this.scaleX = 1.2;
                    this.scaleY = 1.2;
                }

                if (this.hitTimer > 0) this.hitTimer--;
            },

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scaleX, this.scaleY);

                // Hit flash
                if (this.hit) {
                    ctx.filter = 'brightness(2)';
                }

                // Aura glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 120);
                gradient.addColorStop(0, 'rgba(255, 100, 50, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 120, 0, Math.PI * 2);
                ctx.fill();

                // Draw enemy
                if (this.image && this.image.complete) {
                    ctx.drawImage(
                        this.image,
                        -this.width / 2, -this.height / 2,
                        this.width, this.height
                    );
                } else {
                    // Fallback
                    ctx.fillStyle = '#aa3355';
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ENEMY', 0, 5);
                }

                ctx.restore();
            }
        };

        // Load images
        hero.spritesheet = new Image();
        hero.spritesheet.src = 'hero_spritesheet.png';

        enemy.image = new Image();
        enemy.image.src = 'enemy.png';

        // Draw background
        function drawBackground() {
            // Gradient sky
            const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGrad.addColorStop(0, '#1a0a2e');
            bgGrad.addColorStop(0.4, '#2d1b4e');
            bgGrad.addColorStop(0.7, '#1a1a3e');
            bgGrad.addColorStop(1, '#0f0f2a');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Magic circles on ground
            ctx.save();
            ctx.translate(240, 620);
            ctx.scale(1, 0.3);
            const circleGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 200);
            circleGrad.addColorStop(0, 'rgba(100, 50, 200, 0.5)');
            circleGrad.addColorStop(0.5, 'rgba(100, 50, 200, 0.2)');
            circleGrad.addColorStop(1, 'rgba(100, 50, 200, 0)');
            ctx.fillStyle = circleGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 200, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Floating particles in background
            ctx.fillStyle = 'rgba(150, 100, 255, 0.5)';
            for (let i = 0; i < 30; i++) {
                const x = (i * 73 + Date.now() * 0.01) % canvas.width;
                const y = (i * 47 + Math.sin(Date.now() * 0.001 + i) * 50) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw UI
        function drawUI() {
            // Enemy health bar
            const hpX = 90, hpY = 50, hpW = 300, hpH = 25;

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.strokeStyle = '#ff4466';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(hpX, hpY, hpW, hpH, 5);
            ctx.fill();
            ctx.stroke();

            // Fill
            const hpPercent = game.enemyHP / game.enemyMaxHP;
            const hpGrad = ctx.createLinearGradient(hpX, 0, hpX + hpW, 0);
            hpGrad.addColorStop(0, '#ff2244');
            hpGrad.addColorStop(0.5, '#ff6688');
            hpGrad.addColorStop(1, '#ff2244');
            ctx.fillStyle = hpGrad;
            ctx.beginPath();
            ctx.roundRect(hpX + 2, hpY + 2, (hpW - 4) * hpPercent, hpH - 4, 3);
            ctx.fill();

            // Text
            ctx.fillStyle = '#fff';
            ctx.font = '12px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(`${game.enemyHP.toLocaleString()} / ${game.enemyMaxHP.toLocaleString()}`, hpX + hpW / 2, hpY + 17);

            // Enemy name
            ctx.fillStyle = '#ff4466';
            ctx.font = 'bold 14px Cinzel';
            ctx.fillText('SHADOW DRAGON', hpX + hpW / 2, hpY - 10);

            // BB Gauge
            const bbX = 90, bbY = 680, bbW = 300, bbH = 20;
            ctx.fillStyle = '#1a1a2e';
            ctx.strokeStyle = '#ffaa00';
            ctx.beginPath();
            ctx.roundRect(bbX, bbY, bbW, bbH, 5);
            ctx.fill();
            ctx.stroke();

            const bbPercent = game.bbGauge / game.maxBB;
            const bbGrad = ctx.createLinearGradient(bbX, 0, bbX + bbW, 0);
            bbGrad.addColorStop(0, '#ff6600');
            bbGrad.addColorStop(0.5, '#ffcc00');
            bbGrad.addColorStop(1, '#ff6600');
            ctx.fillStyle = bbGrad;
            ctx.beginPath();
            ctx.roundRect(bbX + 2, bbY + 2, (bbW - 4) * bbPercent, bbH - 4, 3);
            ctx.fill();

            ctx.fillStyle = '#ffcc00';
            ctx.font = 'bold 12px Orbitron';
            ctx.fillText('BRAVE BURST', bbX + bbW / 2, bbY + 14);
        }

        // Update particles
        function updateParticles() {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // gravity
                p.alpha -= 0.02;
                p.life--;

                if (p.life <= 0 || p.alpha <= 0) {
                    game.particles.splice(i, 1);
                }
            }
        }

        // Draw particles
        function drawParticles() {
            for (const p of game.particles) {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        // Update damage numbers
        function updateDamageNumbers() {
            for (let i = game.damageNumbers.length - 1; i >= 0; i--) {
                const d = game.damageNumbers[i];
                d.y += d.vy;
                d.vy += 0.1;
                d.alpha -= 0.015;

                if (d.alpha <= 0) {
                    game.damageNumbers.splice(i, 1);
                }
            }
        }

        // Draw damage numbers
        function drawDamageNumbers() {
            for (const d of game.damageNumbers) {
                ctx.save();
                ctx.globalAlpha = d.alpha;
                ctx.font = `bold ${24 * d.scale}px Orbitron`;
                ctx.textAlign = 'center';

                // Shadow
                ctx.fillStyle = '#000';
                ctx.fillText(d.value.toLocaleString(), d.x + 2, d.y + 2);

                // Main color
                ctx.fillStyle = d.crit ? '#ffff00' : '#ff4444';
                ctx.shadowColor = d.crit ? '#ff6600' : '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fillText(d.value.toLocaleString(), d.x, d.y);

                ctx.restore();
            }
        }

        // Apply screen effects
        function applyScreenEffects() {
            // Screen shake
            if (game.screenShake.intensity > 0) {
                game.screenShake.x = (Math.random() - 0.5) * game.screenShake.intensity;
                game.screenShake.y = (Math.random() - 0.5) * game.screenShake.intensity;
                game.screenShake.intensity *= 0.85;
                ctx.translate(game.screenShake.x, game.screenShake.y);
            }

            // Screen flash
            if (game.flashAlpha > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${game.flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                game.flashAlpha *= 0.85;
            }
        }

        // Main game loop
        function gameLoop() {
            ctx.save();

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake
            if (game.screenShake.intensity > 0.1) {
                ctx.translate(game.screenShake.x, game.screenShake.y);
            }

            // Draw
            drawBackground();

            enemy.update();
            enemy.draw(ctx);

            hero.update();
            hero.draw(ctx);

            updateParticles();
            drawParticles();

            updateDamageNumbers();
            drawDamageNumbers();

            drawUI();

            // Screen flash
            if (game.flashAlpha > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${game.flashAlpha})`;
                ctx.fillRect(-50, -50, canvas.width + 100, canvas.height + 100);
                game.flashAlpha *= 0.8;
            }

            // Update screen shake
            if (game.screenShake.intensity > 0) {
                game.screenShake.x = (Math.random() - 0.5) * game.screenShake.intensity;
                game.screenShake.y = (Math.random() - 0.5) * game.screenShake.intensity;
                game.screenShake.intensity *= 0.9;
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'a' || e.key === 'A') game.attack();
            if (e.key === 's' || e.key === 'S') game.skill();
            if (e.key === 'd' || e.key === 'D') game.braveBurst();
        });

        // Utility
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Start
        gameLoop();
    </script>
</body>

</html>